#!/bin/bash

# ------------------------------------------------------------------------------
# | File System                                                                |
# ------------------------------------------------------------------------------

# Create data URI from a file and copy it to the pasteboard

datauri() {

    local mimeType=''

    if [ -f "$1" ]; then
        mimeType=$(file -b --mime-type "$1")
        #                |
        #                do not prepend the filename to the output

        if [[ $mimeType == text/* ]]; then
            mimeType="$mimeType;charset=utf-8"
        fi
        printf "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')" | pbcopy | printf "=> data URI copied to pasteboard.\n"
    else
        printf "'%s' is not a file.\n" "$1"
    fi

}

# ------------------------------------------------------------------------------

# Delete files that match a certain pattern from the current directory

cleanup() {
    local q="${1:-*.DS_Store}"
    find . -type f -name "$q" -ls -delete
}

# ------------------------------------------------------------------------------

# Get gzip information (gzipped file size + reduction size)

gz() {

    declare -i gzippedSize=0
    declare -i originalSize=0

    if [ -f "$1" ]; then
        if [ -s "$1" ]; then

            originalSize=$( wc -c < "$1" )
            printf "\n original size:   %12s\n" "$(hrfs $originalSize)"

            gzippedSize=$( gzip -c "$1" | wc -c )
            printf " gzipped size:    %12s\n" "$(hrfs $gzippedSize)"

            printf " ─────────────────────────────\n"
            printf " reduction:       %12s [%s%%]\n\n" \
                        "$( hrfs $(($originalSize-$gzippedSize)) )" \
                        "$( printf "%s %s" "$originalSize $gzippedSize" | \
                            awk '{ printf "%.1f", 100 - $2 * 100 / $1 }' | \
                            sed -e "s/0*$//;s/\.$//" )"
                            #              |
                            #              remove tailing zeros

        else
            printf "'%s' is empty.\n" "$1"
        fi
    else
        printf "'%s' is not a file.\n" "$1"
    fi

}

# ------------------------------------------------------------------------------

# Determine size of a file or total size of a directory

fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* *;
    fi;
}

# ------------------------------------------------------------------------------

# Find within the directory

f() {
    find . -name "$1"
}

# ------------------------------------------------------------------------------

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.

tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# ------------------------------------------------------------------------------

# Create new directories and enter the first one

mkd() {
    [ -n "$*" ] && mkdir -p "$@" && cd "$@"
    #                     └─ make parent directories if needed
}

# ------------------------------------------------------------------------------

# cd into whatever is the forefront Finder window

cdf() {
    cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# ------------------------------------------------------------------------------

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location

v() {
    if [ $# -eq 0 ]; then
        vim .;
    else
        vim "$@";
    fi
}

# ------------------------------------------------------------------------------

# `o` with no arguments opens the current directory, otherwise opens the given
# location

o() {
    if [ $# -eq 0 ]; then
        open .;
    else
        open "$@";
    fi
}

# ------------------------------------------------------------------------------
# | Miscellaneous                                                              |
# ------------------------------------------------------------------------------

# Simple Calculator

? () {

    local result=''

    #                         default (when --mathlib is used) is 20
    #                         |
    result="$( printf "scale=10;%s\n" "$*" | bc --mathlib | tr -d "\\\n" )"
    #                         remove the tailing "\" and "\n" ─┘
    #                         (large numbers are printed on multiple lines)

    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "%s" "$result" |
        sed -e "s/^\./0./"        `# add "0" for cases like ".5"` \
            -e "s/^-\./-0./"      `# add "0" for cases like "-.5"`\
            -e "s/0*$//;s/\.$//"   # remove tailing zeros
    else
        printf "%s" "$result"
    fi

    printf "\n"

}

# ------------------------------------------------------------------------------

# Extract archives - use: extract <file>

extract() {
    if [ -f "$1" ] ; then
        local filename=$(basename "$1")
        local foldername="${filename%%.*}"
        local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
        local didfolderexist=false
        if [ -d "$foldername" ]; then
            didfolderexist=true
            read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                return
            fi
        fi
        mkdir -p "$foldername" && cd "$foldername"
        case $1 in
            *.tar.bz2) tar xjf "$fullpath" ;;
            *.tar.gz) tar xzf "$fullpath" ;;
            *.tar.xz) tar Jxvf "$fullpath" ;;
            *.tar.Z) tar xzf "$fullpath" ;;
            *.tar) tar xf "$fullpath" ;;
            *.taz) tar xzf "$fullpath" ;;
            *.tb2) tar xjf "$fullpath" ;;
            *.tbz) tar xjf "$fullpath" ;;
            *.tbz2) tar xjf "$fullpath" ;;
            *.tgz) tar xzf "$fullpath" ;;
            *.txz) tar Jxvf "$fullpath" ;;
            *.zip) unzip "$fullpath" ;;
            *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# ------------------------------------------------------------------------------
# | Network                                                                    |
# ------------------------------------------------------------------------------

# Start an HTTP server from a directory, optionally specifying the port

server() {

    local i=0
    local maxNumberOfTries=10
    local port="${1:-8000}"

    # Wait for the server to be available, and once
    # it is, open its address in the default browser
    while [ $i -lt $maxNumberOfTries ]; do
        if [ "$(lsof -i -nP | grep "$port" | grep -i "python")" != "" ]; then
            o "http://localhost:${port}/"
            break;
        fi
        i=$(( i + 1 ))
        sleep 1
    done &

    # Start server
    python -c "

import sys

try:
    import SimpleHTTPServer as server
    import SocketServer as socketserver
except ImportError:

    # In Python 3, the 'SimpleHTTPServer'
    # module has been merged into 'http.server'

    import http.server as server
    import socketserver

handler = server.SimpleHTTPRequestHandler
map = handler.extensions_map
port = int(sys.argv[1])

# Set default Content-Type to 'text/plain'
map[''] = 'text/plain'

# Serve everything as UTF-8 (although not technically
# correct, this doesn't break anything for binary files)
for key, value in map.items():
    map[key] = value + '; charset=utf-8'

# Create, but don't automatically bind socket
# (the 'allow_reuse_address' option needs to be set first)
httpd = socketserver.ThreadingTCPServer(('localhost', port), handler, False)

# Prevent 'cannot bind to address' errors on restart
# http://brokenbad.com/address-reuse-in-pythons-socketserver/
httpd.allow_reuse_address = True

# Manually bind socket and start the server
httpd.server_bind()
httpd.server_activate()
print('Serving content on port:', port)
httpd.serve_forever()

    " "$port"

}

# ------------------------------------------------------------------------------

# whois a domain or a URL

whois() {

    local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
    if [ -z $domain ] ; then
        domain=$1
    fi
    echo "Getting whois record for: $domain …"

    # avoid recursion
    #      |         this is the best whois server
    #      |                      |                  strip extra fluff
    /usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}

# ------------------------------------------------------------------------------
# | Search                                                                     |
# ------------------------------------------------------------------------------

# Search history

qh() {
    #           enable colors for pipe
    #           │  ("--color=auto" enables colors only if
    #           │  the output is in the terminal)
    grep --color=always "$*" "$HISTFILE" |       less -RX
    # display ANSI color escape sequences in raw form ─┘│
    #       don't clear the screen after quitting less ─┘
}

# ------------------------------------------------------------------------------

# Search for text within the current directory

qt() {
    grep -ir --color=always "$*" . | less -RX
    #      -- search all files under each directory, recursively
    #     --- ignore case
}

# ------------------------------------------------------------------------------

# Search and relace text within the current directory

qr() {
    grep -r -l "$1" . | sort | uniq | xargs perl -e "s/$1/$2/" -pi
}

# ------------------------------------------------------------------------------
# | Text Processing                                                            |
# ------------------------------------------------------------------------------

# Human redable file size
# (because `du -h` doesn't cut it for me)

hrfs() {

    printf "%s" "$1" |
    awk '{
            i = 1;
            split("B KB MB GB TB PB EB ZB YB WTFB", v);
            value = $1;

            # confirm that the input is a number
            if ( value + .0 == value ) {

                while ( value >= 1024 ) {
                    value/=1024;
                    i++;
                }

                if ( value == int(value) ) {
                    printf "%d %s", value, v[i]
                } else {
                    printf "%.1f %s", value, v[i]
                }

            }
        }' |
    sed -e ":l; s/\([0-9]\)\([0-9]\{3\}\)/\1,\2/; t l"
    #                          -- add commas to the numbers
    #                             (changes "1023.2 KB" to "1,023.2 KB")
}
